# Concurrent-Programming
Your first task is to implement the change_flight function to make the system fully functional with one thread. To verify it works, compile the "test" program and run it. It will show "no error" if it works as expected. However, it is not thread-safe and if you compile and run "main" with an argument >= 2, such as "make main; ./main 2" it will almost certainly fail due to race conditions (Murphy's Law). A global mutex lock (biglock) is provided in ars.c but not used. Your second task is to employ this lock to provide thread-safety to the ARS. You need to perform lock/unlock in book/cancel/change functions. You don't need to use them in ars_init() and dump_tickets(). Once this is done, "./main &lt;n>" should work correctly with multiple threads (try ./main 2 and ./main 3). Have you observed the slowdown as the number of threads increases? Now, let's look at the code in main.c. Each worker thread performs 10 million operations by random. Since ars uses one big lock, all of the incoming requests must execute sequentially. Can we make it more efficient by exploiting more concurrency? Of course. Since there is no shared data between different flights, we can give each flight its own lock which allows operations on different flights to run concurrently without blocking each other. Your third task is to replace the biglock with some per-flight mutex locks. Be careful with deadlocks! Once this is done, "./main 10" shall finish within 5 seconds. The book_flight function will return -1 if the flight is fully booked, which can be quite annoying. To better serve the customers, you need to roll out a new service called "book_flight_can_wait", which always returns a valid ticket to the caller! If a flight is fully booked, the function must wait until some one have cancelled a ticket. You need to use condition variables to achieve this. You will need to replace the code in book_flight_can_wait() and add necessary structures/code to a few places in ars.c. Once this is done, "./wait &lt;n>" should work correctly with any n > 5. For example, "./wait 8" should finish within 5 seconds. See the lists below for available pthread library functions. pthread functions that you can use:  pthread_mutex_init, pthread_mutex_lock, pthread_mutex_unlock pthread_cond_init, pthread_cond_wait, pthread_cond_signal Don't use the following functions:  pthread_cond_timedwait pthread_cond_broadcast
